package com.xmaser.bitmap{	//import the necessary definitions	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.utils.ByteArray;	public class ColorAndAlphaCompared extends Bitmap {		//variable to hold our greyscale bitmap		private var _greyScale:BitmapData;		//variable to hold our colored bitmap		private var _coloredImage:BitmapData;		// variable to hold the resultant bitmap		private var _newBitmapData:BitmapData;		// variable to hold the our greyscaleImagePixels		private var _origVector:Vector.<uint>;		// variable to hold the our coloredImagePixels		private var _colorVector:Vector.<uint>;		private var _vector:Vector.<uint>;		//pass in references to our colored & greyscale images into our constructor.		public function ColorAndAlphaCompared(bitmapData : BitmapData,greyScaled : BitmapData) {			_vector = new Vector.<uint>();			_greyScale=greyScaled;			_coloredImage=bitmapData;			//instantiate new BitmapData with the width & height of either of our jpg references and set its transparent property to true.			_newBitmapData=new BitmapData(greyScaled.width,greyScaled.height,true,0x00000000);			/*use the lock method on our newBitmapData to prevent our redraws as we add new pixels to it*/			_newBitmapData.lock();			/*pass our bitmapData into the constructor of the super class this class extends. (Bitmap class)*/			super(_newBitmapData);			/*store the pixels of the entire bounds of our greyScale image*/			_origVector=_greyScale.getVector(_greyScale.rect);			/*since we will never adjust the vectors length set it’s fixed value to true*/			_origVector.fixed=true;			/*sore the pixels of the entire bounds of our coloredImage*/			_colorVector=_coloredImage.getVector(_coloredImage.rect);			/*set the fixed variable to true*/			_colorVector.fixed=true;			/*begin the analysis of the two vectors*/			readWrite();		}		/*readWrite:  		This method will loop through each index of both our vectors and store the 		analyzed version into a final vector		*/		protected function readWrite():void {			/*how many times do we need to analyze our data*/			var totalPixels:int=_colorVector.length;			var i:int=0;			/*define the length of our resultant vector*/			_vector.length=totalPixels;			/*set fixed property to true*/			_vector.fixed=true;			/*loop through all pixels until 0 is reached*/			while (--totalPixels) {				/*set the current index of the vector to the result of the two analyzed pixels*/				_vector[totalPixels]=int(shiftPixels(int(_origVector[totalPixels]),int(_colorVector[totalPixels])));			}/* end of our loop*/			/* set the new pixels into the bound area of our _newBitmapData*/			_newBitmapData.setVector(_newBitmapData.rect, _vector);			/* unlock _newBitmapData so that the player will redraw the new content*/			_newBitmapData.unlock();			/*rid the unused content to to free up memory*/			dispose();		}		/*shiftPixels:		 *this method accepts two different pixels.  One to represent the value of		 *alpha and the other merely as the color value.  The two pixels are merged		 *into a resulting 32bit ARGB value and returned to the caller of the 		 *method.		 */		private function shiftPixels(alphaChannel : uint,colorChannel : uint):uint {			/*extract the blue channel from the pixel representing the alpha value*/			var decimal:uint=alphaChannel>>16&0xFF;			/*prepend our blue channel as the alpha of our colorChannel pixel*/			var argb : uint = (decimal << 24) | (ColorAndAlphaCompared.extractRED(colorChannel)<<16) | (ColorAndAlphaCompared.extractGREEN(colorChannel)<<8) | ColorAndAlphaCompared.extractBLUE(colorChannel);			/*return the combined ARGB value*/			return argb;		}		/*Dispose:		        *This method frees up memory used when creating the Transparent image		        */		private function dispose():void {			/*rid the greyScale image*/			_greyScale.dispose();			/*rid the _coloredImage image*/			_coloredImage.dispose();			/*remove the vectors*/			_vector=_colorVector=_origVector=null;			/*remove references to our jpgs*/			_greyScale=_coloredImage=null;		}		/*extractAlpha:		       *This method extracts the alpha value of a supplied hex value		       */		static private function extractALPHA(hex : uint):uint {			return hex >> 24 & 0xff;		}		/*extractRED:		       *This method extracts the red value of a supplied hex value		       */		static private function extractRED(hex : uint):uint {			return hex >> 16 & 0xff;		}		/*extractGREEN:		       *This method extracts the green value of a supplied hex value		       */		static private function extractGREEN(hex : uint):uint {			return hex >> 8 & 0xff;		}		/* extractBLUE:		       *This method extracts the blue value of a supplied hex value		       */		static private function extractBLUE(hex : uint):uint {			return hex & 0xff;		}	}	/**	 * 	 */}